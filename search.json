[{"path":"https://heike.github.io/tmaRks/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 tmaRks authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://heike.github.io/tmaRks/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Heike Hofmann. Author, maintainer.","code":""},{"path":"https://heike.github.io/tmaRks/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hofmann H (2023). tmaRks: Compare Screwdriver Marks. https://github.com/heike/tmaRks, https://heike.github.io/tmaRks/.","code":"@Manual{,   title = {tmaRks: Compare Screwdriver Marks},   author = {Heike Hofmann},   year = {2023},   note = {https://github.com/heike/tmaRks, https://heike.github.io/tmaRks/}, }"},{"path":"https://heike.github.io/tmaRks/index.html","id":"tmarks","dir":"","previous_headings":"","what":"Compare Screwdriver Marks","title":"Compare Screwdriver Marks","text":"goal tmaRks …","code":""},{"path":"https://heike.github.io/tmaRks/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Compare Screwdriver Marks","text":"can install development version tmaRks like :","code":"remotes::install_github(\"heike/tmaRks\")"},{"path":"https://heike.github.io/tmaRks/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Compare Screwdriver Marks","text":"basic example shows solve common problem: Load toolmarks Align set Visualize Download pdf multiple pages figures. steps far : Convert stl files x3p files save appropriate folder Function assert_name_pattern(files, pattern) checks file names vector files compliance pattern given pattern. signature extraction – ’m just filtering signal set value x another. bet makes lose signal, ’s simple. adding metadata –– far haven’t run code, x3p files don’t correct metadata. Nina made spreadsheet information, take run , ’s slow. aligning signatures –– ’m still initial way instead using “tmaRks” way added piece marks length, 900 points, NA fillers either side. figured make modeling easier. One thing haven’t done align signals based two criteria: subset tool (marks different angles) angle. tried aligning marks made different angles alignment didn’t look good. binning –– far ’ve done choosing arbitrary number bins (18, bin 50 points ). nice just change number easily, e.g. b=22, code just run. way ’s written now ’s way dependent 18 bins. modeling –– main task calculating means tool, variance across tools. couldn’t figure general ’ll see ’s quite specific. One point: - concatenating sides –– ’d like start whole analysis using signals sides B tool concatenated. think honest description data . done aligning, think.","code":"library(tmaRks) #>  #> Attaching package: 'tmaRks' #> The following object is masked from 'package:utils': #>  #>     data ## basic example code data(toolmarks) head(toolmarks) #> # A tibble: 6 × 11 #>    tool size  side  direction angle  mark TID            x     y   value signa…¹ #>   <int> <chr> <chr> <chr>     <int> <int> <chr>      <dbl> <dbl>   <dbl>   <dbl> #> 1     1 S     A     F            80     1 T01SA-F80…  2.00  3.62 -0.0816 0.00195 #> 2     1 S     A     F            80     1 T01SA-F80…  2.01  3.62 -0.0816 0.00193 #> 3     1 S     A     F            80     1 T01SA-F80…  2.02  3.62 -0.0816 0.00184 #> 4     1 S     A     F            80     1 T01SA-F80…  2.02  3.62 -0.0817 0.00173 #> 5     1 S     A     F            80     1 T01SA-F80…  2.03  3.62 -0.0817 0.00166 #> 6     1 S     A     F            80     1 T01SA-F80…  2.04  3.62 -0.0817 0.00157 #> # … with abbreviated variable name ¹​signature library(tidyverse, quietly = TRUE) #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.0     ✔ readr     2.1.4 #> ✔ forcats   1.0.0     ✔ stringr   1.5.0 #> ✔ ggplot2   3.4.1     ✔ tibble    3.2.0 #> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0 #> ✔ purrr     1.0.1      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ dplyr::filter() masks stats::filter() #> ✖ dplyr::lag()    masks stats::lag() #> ℹ Use the ]8;;http://conflicted.r-lib.org/conflicted package]8;; to force all conflicts to become errors  reps <- toolmarks %>% filter(tool <= 3, size == \"L\") %>% group_by(tool, side, size) %>%   tidyr::nest() reps <- reps %>% mutate(   data = data %>% purrr::map(sig_align_set, value=signature, group = mark, min.overlap = 500) ) %>% tidyr::unnest(cols=data) reps <- reps %>%    unite(\"id\", tool, side, size, remove = FALSE) %>%   mutate(   plot = purrr::map2(aligned_set, id, .f = function(d, id) {     gg <- d %>% ggplot(aes(x = aligned_x, y = signature, colour = factor(mark))) + geom_line() +       theme_bw() +        ggtitle(id[1]) +       theme(legend.position=\"none\")     gg   }) )  marks_01_A_S <- reps %>% filter(tool==01, side==\"A\", size==\"S\")  length(reps$data)  dim(reps$data[[1]])  table(reps$data[[1]]$direction) table(reps$data[[2]]$direction)   table(reps$data[[3]]$angle)   reps$data[[3]]$angle    dim(marks_01_A_S$data[1])   str(reps) names(reps)     table(reps$tool) table(reps$side) table(reps$size)  reps$data[[1]]$y  reps$    #reps$aligned_set[[3]] %>% summary() #reps$aligned_set[[3]] %>% names() #reps[3,]  library(readr) saveRDS(reps, \"data/reps.rds\")  reps <- readRDS(\"data/reps.rds\")       library(gridExtra) do.call(marrangeGrob, list(reps$plot[1:8], nrow=4, ncol=2))   ml = do.call(marrangeGrob, list(reps$plot, nrow=4, ncol=2)) ggsave(plot=ml, filename=\"figures/multipage.pdf\") stls <- dir(pattern=\"stl\", path=\"data/stl_files\", full.names = TRUE)   for (file in stls) {   stl_tool <- rgl::readSTL(file, plot=FALSE)   x3p <- stl_to_x3p(stl_tool)   x3p %>% x3p_write(file = gsub(\".stl\", \".x3p\", file)) # not that this will re-name EVERY x3p by stl, i.e. no need to deal with stl_files to x3p_files separately }"},{"path":"https://heike.github.io/tmaRks/reference/assert_name_pattern.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure that all files in a vector are correctly named — assert_name_pattern","title":"Ensure that all files in a vector are correctly named — assert_name_pattern","text":"function runs list file names pattern check. warning returned case file names pass check. Offending file names shown. Maria: specific pattern defined \"^Sc\\\\d\\\\d\\\\.Pl\\\\d\\\\d\\\\d\\\\.Ma\\\\d\\\\.S[AB]\\\\.\\\\d\\\\d\\\\.Pb\\\\.Dir(Fo|Ba)\\\\.\\\\Siz[SML](|.mid)\\\\.x3p$","code":""},{"path":"https://heike.github.io/tmaRks/reference/assert_name_pattern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure that all files in a vector are correctly named — assert_name_pattern","text":"","code":"assert_name_pattern(file, pattern, verbose = FALSE)"},{"path":"https://heike.github.io/tmaRks/reference/assert_name_pattern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure that all files in a vector are correctly named — assert_name_pattern","text":"file (vector ) file name(s) pattern format study, generally regular expression. See e.g. https://regexr.com/ help creating suitable patterns verbose logical value whether function chatters re-assurance things works. Defaults FALSE.","code":""},{"path":"https://heike.github.io/tmaRks/reference/assert_name_pattern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure that all files in a vector are correctly named — assert_name_pattern","text":"vector indices files pass check","code":""},{"path":"https://heike.github.io/tmaRks/reference/assert_name_pattern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure that all files in a vector are correctly named — assert_name_pattern","text":"","code":"files <- dir(\"data-raw\", pattern=\".x3p\", recursive = TRUE, full.names=FALSE) assert_name_pattern(files, pattern=\"^T\\\\d\\\\d[SML][AB]-[FB][678]0-0[1-8].x3p$\") #> Warning: 2 file(s) do not match pattern <^T\\d\\d[SML][AB]-[FB][678]0-0[1-8].x3p$>: #> 'NA' #> [1] 1 0"},{"path":"https://heike.github.io/tmaRks/reference/cc_get_signature.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract signature from crosscut — cc_get_signature","title":"Extract signature from crosscut — cc_get_signature","text":"x3p file 3d topological surface processed surface crosscut y,","code":""},{"path":"https://heike.github.io/tmaRks/reference/cc_get_signature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract signature from crosscut — cc_get_signature","text":"","code":"cc_get_signature(ccdata, span1 = 125, span2 = 5, resolution = 0.645)"},{"path":"https://heike.github.io/tmaRks/reference/cc_get_signature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract signature from crosscut — cc_get_signature","text":"ccdata crosscut returned x3p_crosscut span1 span loess fit get profile raw signature span2 span loess fit smooth raw signature resolution numeric value  scan resolution, see x3ptools::x3p_get_scale.","code":""},{"path":"https://heike.github.io/tmaRks/reference/cc_get_signature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract signature from crosscut — cc_get_signature","text":"data frame","code":""},{"path":"https://heike.github.io/tmaRks/reference/cc_get_signature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract signature from crosscut — cc_get_signature","text":"","code":"if (interactive()) { library(x3ptools) x3p <- x3p_read(\"~/Documents/CSAFE/Wirecutter/data/Aluminum Wires renamed/T1AW-LI-R1-B01.x3p\") line1 <- x3p %>% x3p_extract_profile() line1 <- line1$line_df signature <- cc_get_signature(line1, resolution = x3p %>% x3p_get_scale()) }"},{"path":"https://heike.github.io/tmaRks/reference/data.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper function for toolmarks data set in tmaRks package — data","title":"Wrapper function for toolmarks data set in tmaRks package — data","text":"function specific thetoolmarks dataset. unpacks information stored tool ID. allows us store data smaller dataset unpack analysis.","code":""},{"path":"https://heike.github.io/tmaRks/reference/data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper function for toolmarks data set in tmaRks package — data","text":"","code":"data(   ...,   list = character(),   package = NULL,   lib.loc = NULL,   verbose = getOption(\"verbose\"),   envir = .GlobalEnv,   overwrite = TRUE )"},{"path":"https://heike.github.io/tmaRks/reference/data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper function for toolmarks data set in tmaRks package — data","text":"... literal character strings names. list character vector. package character vector giving package(s) look     data sets, NULL. default, packages search path used,     data subdirectory (present) current working     directory. lib.loc character vector directory names R libraries,     NULL.  default value NULL corresponds     libraries currently known. verbose logical.  TRUE, additional diagnostics     printed. envir environment data loaded. overwrite logical: existing objects name     envir replaced?","code":""},{"path":"https://heike.github.io/tmaRks/reference/data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper function for toolmarks data set in tmaRks package — data","text":"","code":"data(toolmarks) dim(toolmarks) #> [1] 386712     11"},{"path":"https://heike.github.io/tmaRks/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://heike.github.io/tmaRks/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://heike.github.io/tmaRks/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://heike.github.io/tmaRks/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align.html","id":null,"dir":"Reference","previous_headings":"","what":"Align two surface cross cuts according to maximal correlation — sig_align","title":"Align two surface cross cuts according to maximal correlation — sig_align","text":"Align two surface cross cuts according maximal correlation","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align two surface cross cuts according to maximal correlation — sig_align","text":"","code":"sig_align(   sig1,   sig2,   min.overlap = round(0.75 * min(length(sig1), length(sig2))) )"},{"path":"https://heike.github.io/tmaRks/reference/sig_align.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align two surface cross cuts according to maximal correlation — sig_align","text":"sig1 vector first signature sig2 vector second signature min.overlap additional parameter passed get_ccf","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align two surface cross cuts according to maximal correlation — sig_align","text":"list consisting ) maximal cross correlation, b) lag resulting highest cross correlation, c) data frame input, y vectors aligned maximal correlation d) list vector correlations vector lags","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Align signatures — sig_align_set","title":"Align signatures — sig_align_set","text":"Align signatures group. signatures group aligned respect first signature group. Alignments vary depending signature used 'first'.","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align signatures — sig_align_set","text":"","code":"sig_align_set(data, value, group, min.overlap = 500)"},{"path":"https://heike.github.io/tmaRks/reference/sig_align_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align signatures — sig_align_set","text":"data data frame id, signatures grouping variable value symbol signature values group symbol (variable) grouping min.overlap value passed get_ccf, see bulletxtrctr::get_ccf.","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align signatures — sig_align_set","text":"data frame: returned data frame number observations input, additional variables aligned_x ccf. Note aligned_x reported integer values. conversion physical extent, scale resolution scan.","code":""},{"path":"https://heike.github.io/tmaRks/reference/sig_align_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align signatures — sig_align_set","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union data(toolmarks) names(toolmarks) #>  [1] \"tool\"      \"size\"      \"side\"      \"direction\" \"angle\"     \"mark\"      #>  [7] \"TID\"       \"x\"         \"y\"         \"value\"     \"signature\" tool2AL <- dplyr::filter(toolmarks, tool == 2, side==\"A\", size==\"L\") # Align all signatures in one go aligned <- tool2AL %>% mutate(mark_angle = interaction(mark, angle)) %>%   sig_align_set(value = signature,  group = mark_angle, min.overlap = 500)  # Visualize the results: library(ggplot2) aligned %>%   ggplot(aes(x = aligned_x, y = signature, colour = mark_angle)) +   geom_line()  # HH: mark 4.60 is still travelling in reversed direction  wide <- aligned %>% select(aligned_x, signature, mark_angle) %>%    tidyr::pivot_wider(values_from = signature, names_from = mark_angle) heatmap(cor(wide %>% select(-aligned_x), use=\"pairwise.complete\"))   # Align signatures separately by angle long <- tool2AL %>% group_by(angle) %>% tidyr::nest() long <- long %>%  mutate(   data = data %>% purrr::map(.f = function(d) {     d %>% sig_align_set(value = signature,  group = mark, min.overlap=500)   }) ) long$data[[3]] %>% ggplot(aes(x = aligned_x, y = signature, colour = factor(mark))) + geom_line()   long <- long %>% tidyr::unnest(col=data) long %>%   ggplot(aes(x =aligned_x, y = signature, colour = factor(mark))) +   geom_line() +   facet_grid(angle~., labeller=\"label_both\")"},{"path":"https://heike.github.io/tmaRks/reference/toolmarks.html","id":null,"dir":"Reference","previous_headings":"","what":"Toolmarks data — toolmarks","title":"Toolmarks data — toolmarks","text":"readable link doi data repo much better, .","code":""},{"path":"https://heike.github.io/tmaRks/reference/toolmarks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Toolmarks data — toolmarks","text":"","code":"toolmarks"},{"path":[]},{"path":"https://heike.github.io/tmaRks/reference/toolmarks.html","id":"toolmarks","dir":"Reference","previous_headings":"","what":"toolmarks","title":"Toolmarks data — toolmarks","text":"data frame 38,6712 rows 13 columns: x numeric value x location ??? y numeric value y location ??? value numeric value surface height ??? signature numeric value signal height tool tool ID, value 1 20 mark iteration, value 1 8 side screwdriver side made mark, B. angle angle attack, one 60, 70, 80. material now marks made lead plates 'Pb'. direction direction toolmark 'Fo'rward 'Ba'ckward. size size screwdriver, 'S', 'M', 'L'","code":""},{"path":"https://heike.github.io/tmaRks/reference/toolmarks.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Toolmarks data — toolmarks","text":"Maria Cuellar, CSAFE collaborative agreement NIST.","code":""},{"path":"https://heike.github.io/tmaRks/reference/x3p_image.html","id":null,"dir":"Reference","previous_headings":"","what":"Show surface matrix as a plot — x3p_image","title":"Show surface matrix as a plot — x3p_image","text":"details come","code":""},{"path":"https://heike.github.io/tmaRks/reference/x3p_image.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show surface matrix as a plot — x3p_image","text":"","code":"x3p_image(x3p, dimension = 3, width = 400, scale = 0.25, texture = \"bw\")"},{"path":"https://heike.github.io/tmaRks/reference/x3p_image.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show surface matrix as a plot — x3p_image","text":"x3p scan x3p format dimension 2 3 width size window scale factor scale original matrix. Large matrices might crash session. texture texture object. Create one rayshader::create_texture use one pre-made one (e.g. \"bw\", \"imhof1\", \"imhof2\", \"imhof3\", \"unicorn\", \"desert\")","code":""},{"path":"https://heike.github.io/tmaRks/reference/x3p_select_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively select a line from a scan — x3p_select_line","title":"Interactively select a line from a scan — x3p_select_line","text":"Interactively select line scan","code":""},{"path":"https://heike.github.io/tmaRks/reference/x3p_select_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively select a line from a scan — x3p_select_line","text":"","code":"x3p_select_line(x3p)"},{"path":"https://heike.github.io/tmaRks/reference/x3p_select_line.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively select a line from a scan — x3p_select_line","text":"x3p x3p object containing scan","code":""}]
